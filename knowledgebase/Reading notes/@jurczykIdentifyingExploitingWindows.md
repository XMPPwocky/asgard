---
title: Identifying and Exploiting Windows Kernel Race Conditions via Memory Access Patterns
authors: Mateusz Jurczyk, Gynvael Coldwind
year: 
DOI: 
---

This paper describes Bochspwn, a tool for automatically identifying [[Double fetch]] issues in the context of the [[Windows kernel]].

The fundamental idea is this: if you perform a syscall, and observe arguments being read (from user-mode memory) multiple times, an attacker could modify the arguments between reads- thus e.g. if a value was fetched, bounds-checked, and then fetched again (before being used), an attacker could change the value to an out-of-bounds one before the second fetch. In short, a classic [[Race condition]].

The authors describe a few possible approaches to detect such a situation-
- modifying the exception/page fault handler to trace accesses to user addresses, and then mapping user addresses as unreadable
- Using a [[Hypervisor]] to do similar things as the previous
- Using an [[Emulator]] emulating an entire system

The authors use the emulator approach, based on [[Bochs (emulator)]] - it provides hooks for instruction execution and for memory accesses. (Presumably Bochs was a more natural choice than [[QEMU (emulator)]] at the time?)

Today, it seems like a more performant approach should be possible (using ... well, not [[Intel PT]] (I don't think?) but something else should be able to log memory accesses efficiently?)

The authors describe "offline" v.s. "online" mode- a bit confusing but AIUI the idea is that in online mode they detect double-fetches immediately (on each access) v.s. in offline mode they just log all accesses (to some storage) and post-process later.

Overhead - compared to uninstrumented Bochs - is ~5x in offline mode, ~8x in online mode

Also lots of RAM overhead

The authors describe some bugs they've found

Future work-

They do link it to generic [[TOCTOU]]. Also describing other stuff you can do with [[Dynamic binary instrumentation]] on a full system... some mention of [[Static analysis]] too (since their dynamic approach can only catch double-fetches when actually triggered.)

Thought: Modern [[Coverage-guided fuzzing]] could probably do a quite good job at triggering double fetches, and the instrumentation you'd need for code coverage is a natural fit

