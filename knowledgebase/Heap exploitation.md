Once trivial. After a dozen or so generations of [[Mitigation cat-and-mouse]], not so much... need more powerful primitives. In contexts where a [[Turing completeness|Turing-complete]] scripting environment (whether intentional or a [[Weird machine|Weird machine]]) is available, often quite doable. Canonical example is [[Javascript]] engines, since obviously browser exploitation

Many approaches, often context-dependent. What [[Exploit primitive]]s do you have, what mitigations are you dealing with. A lot of them end up converting one vulnerability type into another (e.g. [[Buffer overflow]] to a [[Use-after-free]] issue by tricking the allocator into returning already-used memory. SImilarly, [[Double free]] to [[Type confusion]] (get same heap chunk returned by allocator in two different contexts).

Sometimes need to "groom" the heap into a more useful state... this is a common source of [[Nondeterminism]] and unreliable exploits, but if done carefully can be reliable.

# Resources
https://github.com/shellphish/how2heap
